# 逆向学习下一步计划

> 当前进度：已成功绕过 B站 Frida 检测，已用 SSL Hook 拦截到发评论的完整明文请求，并用 Python 验证了 sign 算法。
> 上一篇：[bilibili_ssl明文拦截_技术实录.md](./bilibili_ssl明文拦截_技术实录.md)

---

## 已完成的里程碑

- [x] Frida 环境搭建（frida-tools + frida-server 17.7.3）
- [x] 绕过 libmsaoaidsec.so 反 Frida 检测（bypass.js）
- [x] 找到并 Hook B站两套 libssl.so（系统 Conscrypt + 自带 BoringSSL）
- [x] 解析 HTTP/2 帧 + gRPC + REST 流量
- [x] gzip 解压（修复 z_stream 大小 bug）
- [x] 成功抓到发评论完整明文（含 message、sign、access_key）
- [x] Python 验证 sign 算法（confirm：MD5 + 全参数 URL 编码值 + appSecret）

---

## 下一步方向（按优先级排序）

---

### 选项一：逆向 sign 签名算法（下一步重点）

**目标**：不靠网络资料，自己通过逆向手段找到 appSecret 在 APK 中的位置并提取它，最终用 Python 脚本独立调用 B站 API。

---

#### 已知情报（Python 验证脚本已确认）

```
验证脚本：C:\lsd_project\app_reverse\sign_verify\verify_sign.py
验证脚本：C:\lsd_project\app_reverse\sign_verify\verify_sign2.py

已确认算法：
  1. 所有参数（不含 sign）按 key 字母序排列
  2. 值保持 URL 编码状态（不解码）：message=%E5%93%88%E5%93%88
  3. 拼成 key1=val1&key2=val2&... 字符串
  4. 末尾拼上 appSecret
  5. 对整个字符串计算 MD5

已确认数据：
  appkey    = 1d8b6e7d45233436
  appSecret = 560c52ccd288fed045859ed18bffd973  ← Python 验证通过
  sign      = 83f5e24c3e2a92761f06d274ff412fb2   ← 抓包值，与计算结果完全吻合
```

**appSecret 来源**：从以下公开资料中获取，Python 脚本验证后与抓包 sign 完全吻合：
- https://github.com/SocialSisterYi/bilibili-API-collect/blob/master/docs/misc/sign/APP.md
- https://github.com/Vespa314/bilibili-api/blob/master/api.md

> ⚠️ **重要：appSecret 是从网络公开资料中获取的，不是自己逆向出来的。**
> 我们的目标是明天自己通过逆向手段独立找出这个值，用 verify_sign.py 验证。

---

#### 网络公开资料来源与逆向思路参考

> ⚠️ 注意：bilibili-API-collect 仓库已于 2026 年 1 月 30 日被 B站律师函强制关闭，
> 原文档已删除。以下为仍可访问的参考资料。

---

**1. bilibili-API-collect（已归档，原文档已删除）**

- 仓库地址：https://github.com/SocialSisterYi/bilibili-API-collect
- 原文档路径：`docs/misc/sign/APP.md`（现已404，内容已被删除）
- **关键内容摘要**（来自搜索引擎缓存）：
  - 通过抓包 + APK 逆向，收集了各版本 appkey/appsec 对照表
  - 算法说明：参数按 key 字母序排列 → URL 编码序列化 → 拼上 appsec → MD5
  - 提供了 Python/Java/JavaScript 多语言实现示例
  - **逆向方法**：逆向者从多个 App 版本的 APK 中提取 .so 文件，再用 strings 工具或 IDA 搜索已知 appkey 字符串的附近位置，找到配对的 appSecret

---

**2. 模拟 Bilibili Android 客户端登录分析**

- 原文链接：https://www.hiczp.com/wang-luo/mo-ni-bilibili-android-ke-hu-duan-deng-lu.html
- **逆向思路摘要**（大神的分析路径）：
  1. **抓包发现规律**：用 Charles 拦截发现所有请求都有 `sign` 字段，且每次不同
  2. **定位 sign 生成位置**：在 jadx 里全局搜索 `"sign"` 字符串，找到 `SignHelper` 或类似工具类
  3. **发现 JNI 调用**：Java 层的 sign 方法标记为 `native`，实际在 .so 里实现
      ```java
      // Java 层看到的样子（jadx 反编译结果）：
      public static native String getAppSecret();
      // 说明 appSecret 在 native 层，Java 直接取不到
      ```
  4. **转向 .so 分析**：用 `strings` 命令或 IDA Pro 在 .so 文件里搜索 appkey 值附近的字符串
  5. **证书绑定问题**：Android 7+ 有证书锁定，Charles 等工具被屏蔽，这也是为什么需要 Frida Hook SSL 层的根本原因

---

**3. MD-BiliBili 早期开源客户端（历史参考）**

- 源码：https://github.com/Qixingchen/MD-BiliBili/blob/master/Secret.java
- **意义**：早期版本 appSecret 直接硬编码在 Java 层，现在已经迁移到 .so
- 说明了 B站安全机制的演化路径：`Java 硬编码` → `JNI 调用 .so` → `so 加密/混淆`

---

#### 逆向执行步骤（明天自己完成）

**Step 1 — jadx 静态分析**
```bash
# 下载地址：https://github.com/skylot/jadx/releases
# 下载 jadx-1.5.1-no-jre-win.zip（Windows 版）
# 解压后运行 jadx-gui.bat，打开 B站 APK

# 搜索策略：
# 1. 搜索 appkey 值 "1d8b6e7d45233436"，定位到使用处
# 2. 在附近找 appSecret 字符串（可能在同一个类，或通过 JNI 调用 .so）
# 3. 如果在 Java 层找不到 → 说明藏在 .so 里，进入 Step 2
```

**Step 2 — Frida 动态 Hook MD5（若 jadx 找不到）**
```javascript
// 思路：在发评论时，App 会调用 MD5 函数
// Hook libcrypto.so 的 MD5_Update，截获正在被 hash 的字符串
// 其中必然包含 "sorted_params + appSecret" 的完整明文

var MD5_Update = Module.findExportByName("libcrypto.so", "MD5_Update");
// 拦截 → 读 args[1]（数据指针）和 args[2]（长度）→ 打印字符串
```

**Step 3 — 验证**
```bash
# 把逆向找到的 appSecret 填入 verify_sign.py，运行：
python C:\lsd_project\app_reverse\sign_verify\verify_sign.py
# 如果输出 ✅ 验证成功，逆向完成！
```

**最终产出**：Python 脚本，能直接 POST 到 `/x/v2/reply/add`，不依赖 App。

---

**学到的技能**：
- jadx 静态反编译分析，在 Java 层找硬编码常量
- 识别 JNI 调用（Java 层 `native` 方法 → .so 层实现）
- Frida Hook 加密函数，截获 MD5 输入明文

---

### 选项二：TLS Session Key 导出（Wireshark 解密）

**目标**：导出 TLS 1.3 的 session key，让 Wireshark 能解密抓到的所有 B站流量。

**原理**：
```
BoringSSL 有一个 keylog 回调接口：
SSL_CTX_set_keylog_callback(ctx, callback)

每次 TLS 握手生成密钥时，会调用这个 callback，
参数就是 SSLKEYLOGFILE 格式的一行：
  CLIENT_RANDOM <random> <master_secret>

我们 Hook 这个 callback，把密钥写到文件，
Wireshark 加载这个文件就能解密所有 TLS 流量。
```

**执行步骤**：
1. 在 libignet.so 中找到 `SSL_CTX_set_keylog_callback` 或密钥写入点
2. Hook 后把 keylog 写到 `/sdcard/keylog.txt`
3. tcpdump 同时抓包
4. Wireshark 加载 keylog 文件，全部流量解密可见

**难点**：TLS 1.3 的密钥派生过程比 TLS 1.2 复杂，函数位置需要在 libignet.so 里找。

---

### 选项三：探索其他 API 接口

**目标**：用现有 ssl_hook.js 摸清 B站其他功能的接口结构。

**可以探索的操作**：

| 操作 | 预期接口 | 目的 |
|------|---------|------|
| 点赞 | POST /x/web-interface/archive/like | 分析 sign 是否通用 |
| 投币 | POST /x/web-interface/coin/add | 同上 |
| 收藏 | POST /x/v3/fav/resource/deal | 同上 |
| 关注 | POST /x/relation/modify | 验证 access_key 通用性 |

---

## 工具清单

| 工具 | 用途 | 状态 |
|------|------|------|
| Frida 17.7.3 | 动态 Hook | ✅ 已配置 |
| bypass.js | 绕过检测 | ✅ 可用 |
| ssl_hook.js | SSL 明文拦截 | ✅ 可用 |
| jadx | APK 静态反编译 | 待安装 |
| Python 3 | 算法验证 + API 调用 | 待使用 |

---

## jadx 安装（选项一需要）

```bash
# 下载地址：https://github.com/skylot/jadx/releases
# 下载 jadx-1.5.0-no-jre-win.zip（Windows 版）
# 解压后运行 jadx-gui.bat
# 打开 B站 APK，搜索 appkey 值：1d8b6e7d45233436
```

---

## 明天开始的第一步

```bash
# 方向：自己逆向找 appSecret，不看网上答案

# 路线一（先试，快）：jadx 静态分析
# 1. 安装 jadx，打开 B站 APK
# 2. 搜索 "1d8b6e7d45233436"，找 appSecret 附近的字符串
# 3. 用 verify_sign.py 验证找到的值

# 路线二（jadx 找不到时）：Frida 动态 Hook MD5
# 1. 启动 frida-server
adb shell su -c "/data/local/tmp/frida-server &"

# 2. 注入（同时加载 bypass + 新的 md5_hook.js）
frida -U -f tv.danmaku.bili \
  -l "C:\lsd_project\app_reverse\bilibili_frida绕过\bypass.js" \
  -l "C:\lsd_project\app_reverse\bilibili_frida绕过\md5_hook.js"

# 3. 发一条评论，观察 MD5_Update 截获的明文
# 4. 字符串末尾去掉参数部分，剩余即为 appSecret
# 5. 用 verify_sign.py 验证
```
